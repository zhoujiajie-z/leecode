# 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

* **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
* **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
* **那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。

# == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

* 对于基本数据类型来说，`==` 比较的是值。
* 对于引用数据类型来说，`==` 比较的是对象的内存地址。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

`equals()` 方法存在两种使用情况：

* **类没有重写 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
* **类重写了 `equals()`方法** ：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。
* `String` 中的 `equals` 方法是被重写过的， `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象

# 为什么要有 hashCode？

`hashCode()` 和 `equals()`都是用于比较两个对象是否相等, 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

**那为什么 JDK 还要同时提供这两个方法呢？**

* 这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）

**那为什么不只提供 `hashCode()` 方法呢？**

* 这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。

**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**

* 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
* 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
* 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

# 为什么重写 equals() 时必须重写 hashCode() 方法？

* `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
* 如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等, 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。

# 重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap可能会出现什么问题。

* HashMap在put一个键值对时，会先根据键的`hashMap` 和 `equals` 方法来同时判断该键在容器（红黑树或表）中是否已经存在，如果存在则覆盖，反之新建。所以如果我们在重写 `equals` 方法时，没有重写`hashMap` 方法，那么`hashMap` 方法还是会默认使用Object提供的原始方法，而Object提供的`hashMap` 方法返回值是不会重复的(也就是说每个对象返回的值都不一样)。所以就会导致每个对象在`hashMap` 中都会是一个新的键。
*  若一个类中重写了 `equals` 方法，没有重写`hashCode`方法；且该类的两个对象具有不同属性但 hashCode 相等（有可能是相等的），在`hashMap`以该对象为键进行存储时，会出现hash冲突现象，但发现该类重写了equals 方法，且通过该类的equals 比较之后也是相等，就会出现 `hashMap` 中只保存了一个对象，采用get 方法获取时，就会获取到别的对象，从而导致获取对象错乱。

# String、StringBuffer、StringBuilder 的区别？

* `String` 是不可变的，线程安全。每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
* `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。
* `StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

# String 为什么是不可变的?

* 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
* `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

# String的equals() 和 Object的equals() 有何区别？

* `String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

# try-catch-finally 如何使用？

* `try`块 ： 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
* `catch`块 ： 用于处理 try 捕获到的异常。
* `finally` 块 ： 无论是否捕获或处理异常，**`finally` 块里的语句都会被执行**。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

在以下 2 种特殊情况下，`finally` 块的代码也不会被执行：

*  finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行
* 程序所在的线程死亡。
* 关闭 CPU。

# 注解的解析方法有哪几种？

* **编译期直接扫描** ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
* **运行期通过反射处理** ：像框架中自带的注解(比如 Spring 框架的 `@Value` 、`@Component`)都是通过反射来进行处理的。

# 什么是序列化?什么是反序列化?

* **序列化**： 将数据结构或对象转换成二进制字节流的过程
* **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

下面是序列化和反序列化常见应用场景：

* 对象在进行网络传输（比如远程方法调用 `RPC` 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
* 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
* 将对象存储到数据库（如` Redis`）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
* 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

#  I/O 流为什么要分为字节流和字符流呢?

* 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；
* 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题

# BIO、NIO 和 AIO 的区别？

* **BIO 属于同步阻塞 IO 模型** 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。
* NIO (Non-blocking/New I/O)，IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。
* AIO (Asynchronous I/O)，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

#  获取 Class 对象的四种方式

* 知道具体类的情况下可以使用：`Class alunbarClass = TargetObject.class;`

  * 通过此方式获取 Class 对象不会进行初始化

* 通过 `Class.forName()`传入类的全路径获取：

  `Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`

* 通过对象实例`instance.getClass()`获取：

```java
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```

*  通过类加载器`xxxClassLoader.loadClass()`传入类路径获取:
  * 通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行

​	`ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");`

# 接口和抽象类有什么共同点和区别？

共同的：

* 都不能被实例化
* 都可以包含抽象方法
* 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）

不同点：

* 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
* 一个类只能继承一个类，但是可以实现多个接口
* 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

#  Java 和 C++ 的区别?

* Java 不提供指针来直接访问内存，程序内存更加安全
* Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
* Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
* C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载

#  重载和重写有什么区别？

* 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译期
* 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写
  * 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类
  * 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明
  * 构造方法无法被重写

#  Java 中的几种基本数据类型了解么？

Java 中有 8 种基本数据类型，分别为：

* 6 种数字类型： 
  * 4 种整数型：`byte`、`short`、`int`、`long`
  * 2 种浮点型：`float`、`double`
* 1 种字符类型：`char`
* 1 种布尔型：`boolean`

# Java里面的集合有哪些？

Java集合类主要由两个接口Collection和Map派生出来的，Collection有三个子接口：List、Set、Queue。

# 说说 List, Set, Queue, Map 四者的区别？

* `List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。
* `Set`(注重独一无二的性质): 存储的元素是无序的、不可重复的。
* `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
* `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值

#  ArrayList 与 LinkedList 区别?

* **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
* **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构
* **插入和删除是否受元素位置的影响：**
  * `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 
  * `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响，时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话， 时间复杂度为 O(n) 
* **是否支持快速随机访问：**`LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象
* **内存空间占用：**`ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）

# 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

* `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
* `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
* `HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

# HashMap 和 Hashtable 的区别

* **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰
* **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点
* **对 Null key 和 Null value 的支持：**`HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`
* **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小

# HashSet 如何检查重复?

当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

# ConcurrentHashMap 和 Hashtable 的区别

* `ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现线程安全的方式上不同。
*  JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
* **实现线程安全的方式（重要）：**
  * 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
  * 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
  * **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

# hashmap在什么情况下会产生线程不安全的情况

* 扩容时可能造成死循环，扩容时会造成[死锁](https://so.csdn.net/so/search?q=死锁&spm=1001.2101.3001.7020)，形成环形链表；或者造成扩容大小不一致等问题
* 多个线程put的时，get的值可能不一致，put的操作不是原子性的
* 当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改。

#  什么是线程和进程?

* 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
* 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多

* **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

# 说说线程的生命周期和状态?

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：

* NEW: 初始状态，线程被创建出来但没有被调用 `start()`
* RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态
* BLOCKED ：阻塞状态，需要等待锁释放
* WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）
* TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待
* TERMINATED：终止状态，表示该线程已经运行完毕

线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。**TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，当超时时间结束后，线程将会返回到 RUNNABLE 状态。当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。线程在执行完了 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

#  sleep() 方法和 wait() 方法对比

* **共同点** ：两者都可以暂停线程的执行。
* **区别** ：
  * **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
  * `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
  * `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒
  * `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法

# 线程间通讯方式

线程通信主要可以分为三种方式，分别为**共享内存**、**消息传递**和**管道流**

* volatile关键字
  * 共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信
  * volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。
* 等待/通知机制
  * **等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。**上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的  关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作（注意此机制要和锁一起使用，调用notify的线程执行完后释放了锁新唤醒线程才能运行）
* join()方法
  * 当在一个线程调用另一个线程的join方法时，当前线程阻塞，等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。

# Java的内存机制

Java 把内存划分成两种：一种是栈内存，另一种是堆内存。

* **栈（stack）**是由编译器自动分配和释放的一块内存区域，主要用于存放一些基本类型（如int、float等）的变量、指令代码、常量及对象的引用变量（也就是对象的引用地址）
  * 栈内存的操作方式类似于数据结构中的栈（仅在表尾进行插入或删除操作的线性表）。**栈的优势**在于，它的存取速度比较快，仅此于寄存器，栈中的数据还可以共享。其**缺点**表现在，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
* **堆（heap）**是一个程序运行动态分配的内存区域，在Java中，构建对象时所需要的内存从堆中分配。这些对象通过new指令“显式”建立，这种分配方式类似于数据结构中的链表。堆内存在使用完毕后，是由垃圾回收（Garbage Collection,GC）器“隐式”回收的。
  * **堆的优势**是在于动态地分配内存大小，可以“按需分配”，其生存期也不必事先告诉编译器，在使用完毕后，Java的垃圾收集器会自动收走这些不再使用的内存块。其**缺点**为，由于要在运动时才动态分配内存，相比于栈内存，它的存取速度较慢。

# Redis持久化数据和缓存怎么做扩容？

* 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
* 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有[Redis集群](https://so.csdn.net/so/search?q=Redis集群&spm=1001.2101.3001.7020)可以做到这样。

# JVM对象的实例化

* 判断对象对应的类是否加载、链接、初始化

* 为对象分配内存

* 处理并发安全问题

  * 采用CAS失败重试，区域加锁保证更新的原子性
  * 每个线程预先分配一块TLAB

* 初始化分配到的空间

  * > 给对象的属性赋值操作
    >
    > 1. 属性的默认初始化
    > 2. 显式初始化/代码块中初始化
    > 3. 构造器中初始化

* 设置对象的对象头

* 执行init方法进行初始化

# @Autowired和@Resource区别

* 提供方不同
  *  @Autowired 是Spring提供的，@Resource 是[J2EE](https://so.csdn.net/so/search?q=J2EE&spm=1001.2101.3001.7020)提供的。
* 装配时默认类型不同
  * @Autowired只按type装配,@Resource默认是按name装配

* 使用区别
  * @Autowired与@Resource都可以用来装配bean，都可以写在**字段**或**setter**方法上
  * **@Autowired默认按类型装配**，默认情况下必须要求依赖对象存在，如果要**允许null值**，可以设置它的**required属性**为**false**。如果想**使用名称装配**可以**结合@Qualifier注解**进行使用。
  * @Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。

# 说一下公平锁和非公平锁的区别？

* 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
  * 优点：所有的线程都能得到资源，不会饿死在队列中
  * 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大
* 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁
  * 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量
  * 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死

# 线程池等待队列默认是什么

`LinkedBlockingQueue` 是[线程池](https://so.csdn.net/so/search?q=线程池&spm=1001.2101.3001.7020)默认使用的任务队列

* `LinkedBlockingQueue` 是基于链表结构的阻塞队列，默认容量为 `Integer.MAX_VALUE`，可以认为是无界队列
* `LinkedBlockingQueue` 队列按 FIFO（先进先出）排序元素
* `LinkedBlockingQueue` 内部使用两个独占锁来保证线程安全，其中写入锁用于控制添加元素的操作，取出锁用于控制取出元素的操作。新元素从队列尾部入队，取出元素则从队列头部移除，因此可以同时在队列头部和队列尾部并发地进行元素取出、添加操作

# 线程池都有哪几种工作队列

* ArrayBlockingQueue：是一个基于数组结构的**有界阻塞队列**，此队列按 FIFO（先进先出）原则对元素进行排序。
* LinkedBlockingQueue：一个基于链表结构的**阻塞队列**，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。
* SynchronousQueue：一个不存储元素的**阻塞队列**。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue
* PriorityBlockingQueue：一个具有优先级的**无限阻塞队列**

# 线程池有哪几种 

* newCachedThreadPool：创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。
  * 线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）
  * 线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟）
  * 当线程池中，没有可用线程，会重新创建一个线程
* newFixedThreadPool：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
  * 线程池中的线程处于一定的量，可以很好的控制线程的并发量
  * 线程可以重复被使用，在显示关闭之前，都将一直存在
  * 超出一定量的线程被提交时候需在队列中等待
* newSingleThreadExecutor：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
  * 线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行
* newScheduleThreadPool：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
  * 线程池中具有指定数量的线程，即便是空线程也将保留
  * 可定时或者延迟执行线程活动
* newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。
  * 线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行
  * 可定时或者延迟执行线程活动

# 双亲委派机制了解吗

双亲委派机制 Parent Delegation Model，又称为父级委托模型。

**双亲委派机制，是按照加载器的层级关系，逐层进行委派。**

要加载一个类MyClass.class，从低层级到高层级一级一级委派，先由应用层加载器委派给扩展类加载器，再由扩展类委派给启动类加载器；启动类加载器载入失败，再由扩展类加载器载入，扩展类加载器载入失败，最后由应用类加载器载入，如果应用类加载器也找不到那就报ClassNotFound异常了。

* 双亲委派机制的优点：
  * 保证安全性，层级关系代表优先级，也就是所有类的加载，优先给启动类加载器，这样就保证了核心类库类
  * 避免重复，如果父类加载器加载过了，子类加载器就没有必要再去加载了

# Java的类加载过程

类加载的过程主要分为三个部分：加载、链接、初始化，而链接又可以细分为三个小部分：	验证、准备、解析

* 加载指的是通过全类名获取定义此类的二进制字节流，将字节流所代表的静态存储结构转换为方法区的运行时数据结构在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口
  * **字节码来源**。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
  * **类加载器**。一般包括**启动类加载器**，**扩展类加载器**，**应用类加载器**，以及用户的**自定义类加载器**
* 验证主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误
* **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配
* 解析是将常量池内的符号引用替换为直接引用的过程
  * **符号引用**。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息
  * **直接引用**。可以理解为一个内存地址，或者一个偏移量。比如**类方法，类变量**的直接引用是指向方法区的**指针**；而**实例方法，实例变量**的直接引用则是从实例的头指针开始算起到这个实例变量位置的**偏移量**
* 初始化这个阶段主要是对**类变量**初始化，是执行类构造器的过程 ，换句话说，只对static修饰的变量或语句进行初始化
  * 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类
  * 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行

# 为什么会有自定义类加载器

* 一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载
* 另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载

# 索引

索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树

#  索引的优缺点

优点：

* 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

缺点：

* 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率
* 索引需要使用物理文件存储，也会耗费一定空间

# 有没有什么情况下用了索引反而使得查询变慢吗 

遇到一部分查询条件没索引，一部分有索引的时候，因为有一部分没索引所以肯定会全盘扫描，这时候这个扫描索引部分就多余了 

比如说数据量很小，你再加个什么b➕树的索引，数据全缩到一个点上，加这个索引还不如直接一个一个扫呢

# 最左前缀匹配原则

最左前缀匹配原则指的是，在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 **`>`**、**`<`**、**`between`** 和 **`以%开头的like查询`** 等条件，才会停止匹配。

所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据

# 聚簇索引和非聚簇索引的区别

* **聚簇索引**：将索引和表数据放到同一个节点中，索引结构的[叶子节点](https://so.csdn.net/so/search?q=叶子节点&spm=1001.2101.3001.7020)存放数据，找到了索引，即找到了数据。一个表只能有一个聚簇索引
* **非聚簇索引**：索引存储和数据存储分离，索引结构的叶子节点指向数据的位置。通过索引找到位置，再通过位置找到数据，这个过程叫做**回表查询**。一个表可以有多个非[聚簇索引](https://so.csdn.net/so/search?q=聚簇索引&spm=1001.2101.3001.7020)。非聚簇索引也成为**辅助索引**

# 非聚簇索引一定回表吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行[回表查询](https://so.csdn.net/so/search?q=回表查询&spm=1001.2101.3001.7020)。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

# 主键和唯一索引的区别

* 主键一定会创建一个唯一索引，有唯一索引的列不一定为主键
* 主键不允许空值，唯一索引列允许空值
* 一个表只能有一个主键，但是可以有多个唯一索引
* 主键可以被其它表引用为外键，唯一索引列不可以
* 主键是一种约束，而唯一索引是一种索引，两者在本质上是不同的

# 什么是事务

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行

#  事务隔离级别

* **READ-UNCOMMITTED(读取未提交)** ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
* **READ-COMMITTED(读取已提交)** ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
* **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
* **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读

# 数据库事务的四个特性

* **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
* **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
* **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
* **持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

# 数据库默认隔离级别

* **MySQL**: **Repeatable Read**, 可重复读
* **Oracle, SqlServer**: **Read Commited** , 读已提交

# 怎么解决的幻读

MVCC + Next-key-Lock 防止幻读

* **执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**
  * 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”
* **执行 select...for update/lock in share mode、insert、update、delete 等当前读**
  * 在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 [Next-key Lock](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks) 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读

#  jvm内存分布情况

**线程私有的：**

* 程序计数器
* 虚拟机栈
* 本地方法栈

**线程共享的：**

* 堆
* 方法区
* 直接内存 (非运行时数据区的一部分)

# 虚拟机栈

虚拟机栈存储**当前线程运行java方法所需的数据、指令、返回地址**，**虚拟机栈就是用来存储线程运行方法中的数据的**。虚拟机栈这个内存也不是无限大，它有大小限制，默认情况下是  1M。如果我们不断的往虚拟机栈中入栈帧，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。会抛出Exception in thread "main" java.lang.StackOverflowError

虚拟机栈描述的是**java方法执行的内存模型**，每一个方法在执行的同时都会打包成一个栈帧（Stack Frame）压入虚拟栈。每一个方法从调用至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

**虚拟机栈是基于线程的：**哪怕你只有一个main方法，也是以线程的方式运行的 。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期和线程一样的，随着线程的创建而创建，随着线程的死亡而死亡。

**栈帧：**在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。

**局部变量表:**局部变量的表，用于存储方法的变量，基础数据类型和对象的引用。存放编译期可知的 Java 八大基础数据类型数据、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）

**操作数栈：**存放 java 方法执行时执行引擎的操作数（字节码指令）。操作数栈就是用来操作的，操作的元素可以是任意的  java 数据类型。所以一个方法刚刚开始的时候，这个方法的操作数栈就是空的。可以把执行引擎看成cpu，把操作数栈看成缓存，把局部变量表看成内存

# 虚拟机栈的构成

局部变量表、操作数栈、动态连接、返回地址（完成出口）

# 虚拟栈为什么要放一个操作数栈

因为操作引擎只负责执行jvm命令不负责存储，在计算的时候必定有些数据需要存储在操作数栈里。操作数栈有点类似于高速缓存，操作引擎类似cpu。比如在执行1+1操作的时候，class字节码文件反汇编后的三条命令是 iload1，iload2，iadd，然后操作引擎会依次执行iload1压栈一个1，执行iload2压栈一个1，执行iadd弹出操作数栈最上面两个数求和再压入。

# 方法区

方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

# MySQL性能优化有哪些方式

* 尽可能把所有列定义为 NOT NULL
  * 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；
  * 进行比较和计算时要对 NULL 值做特别的处理。
* 同财务相关的金额类数据必须使用 decimal 类型
  * decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据
  *  由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 
* 避免使用子查询，可以把子查询优化为 join 操作
  * **子查询性能差的原因：** 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询
* 对应同一列进行 or 判断时，使用 in 代替 or
* 限制每张表上的索引数量,建议单张表索引不超过 5 个
* 尽量控制单表数据量的大小，建议控制在 500 万以内
* 经常一起使用的列放到一个表中, 避免更多的关联操作
*  优先选择符合存储需要的最小的数据类型
* 对于频繁的查询优先考虑使用覆盖索引
  * **避免 InnoDB 表进行索引的二次查询:** InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率
  * **可以把随机 IO 变成顺序 IO 加快查询效率:** 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO
* 尽量避免使用外键约束
  * 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
  * 外键可用于保证数据的参照完整性，但建议在业务端实现
* 在明显不会有重复值时使用 UNION ALL 而不是 UNION
  * UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
  * UNION ALL 不会再对结果集进行去重操作

# 什么是覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**

# TCP 与 UDP 的区别

* **是否面向连接** ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。
* **是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
* **是否有状态** ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（**这很渣男！**）。
* **传输效率** ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。
* **传输形式** ： TCP 是面向字节流的，UDP 是面向报文的。
* **首部开销** ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。
* **是否提供广播或多播服务** ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；

# 什么时候选择 TCP,什么时候选 UDP

* **UDP 一般用于即时通信**，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大
* **TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等

# HTTP 基于 TCP 还是 UDP？

HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 **基于 UDP 的 QUIC 协议** 。此变化主要为了解决 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。

# synchronized 和 volatile 有什么区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在

* `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 
* `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证
* `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性

# Spring Boot最重要的三个注解

@EnableAutoConfiguration（自动配置）、@SpringBootConfiguration（声明配置类）、@ComponentScan（组件扫描）

# SpringBoot加载配置文件

1. 通过@value注解实现参数加载
2. 通过@ConfigurationProperties注解实现参数加载
3. 通过@PropertySource注解实现配置文件加载，@PropertySource不支持直接解析yml文件，只能解析properties文件
4. 通过自定义环境处理类，实现配置文件的加载。创建一个实现自EnvironmentPostProcessor接口的类，然后自行加载配置文件

# Redis八大数据类型及其应用场景

1. String，一个key对应一个value，可以包含任何数据，每个String最大支持512M的存储。

**应用场景：**

* 存储对象（不推荐使用）如果要存储对象，一般来说会把对象序列化成一个json的字符串，取出的话也需要反序列化，这样话增加了系统的开销。如果要修改对象中某个值，这个对象需要全部取出来，只修改了一个值，然后再放回去，同样会增加系统的开销
* 存储Mysql中的某个字段
* 文章的点赞数，小视频的点赞数，有点击喜欢的操作就 +1，取消喜欢的操作就 -1

2. Hash，是一个键值对集合，是一String类型的field和value的映射表，类似Java中的Map<String,Object>

**应用场景：**

适用于存储对象，比如说存储user:001这个对象，直接存储成hash即可，要想修改user:001 的age 属性，直接把通过set user:001 age 108，**省去了String中因为修改对象的一个属性，把整个对象都操作一遍的麻烦**

3. List可以理解为是一个简单的字符串列表（双向链表），按照插入顺序排序，可以添加元素到列表的头部（左边）或者尾部（右 边），其底层实现是一个双向链表，连端添加元素的时间复杂度是O(1)，效率高，通过索引下标操作中间节点的数据效率可能低，可参考Java中的LinkedList

**应用场景：**

* 顺序任务池：可以利用Lists的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行，类似消息队列
* 按时间顺序排序,文章列表

4. Set：对外提供的功能和list相似的列表的功能，但set是不允许数据重复，是String类型的无序集合，底层是一个value为null的hash表，所以添加、删除、查找的复杂度是O(1)

**应用场景：**

* 随机抽奖
* 社交需求（共同关注，可能认识的人等）

5. Zset：，是一个没有重复元素的字符串集合，其中每个成员都关联了一个评分(score)，这个评分(score)按照最低分到最高的方式对该集合中的成员进行排序，集合是唯一的，评分可以重复

**应用场景：**

* 实现文章阅读量排行榜
* 打赏排行榜

6. Bitmap：bitmap是由0和1状态表现的二进制位的bit数组，本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作

**应用场景：**

* 大数据量场景下可以用来存储网站的访问次数
* 统计连续打卡的天数等

7. HyperLogLogs：用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。只是进行不重复的基数统计，只统计数量，不记录数据的具体内容

**应用场景：**

针对大数据量的基数统计，例如：做一些门户网站UV（独立访客）的统计

8. Geospatial：地理信息的缩写,就是元素的2维坐标，在地图上就是经纬度

**应用场景：**

用于直线距离的计算

* 外卖软件中附近的美食店铺
* 打车软件附近的车辆等等

# Redis简述穿透/击穿/雪崩和解决方法

